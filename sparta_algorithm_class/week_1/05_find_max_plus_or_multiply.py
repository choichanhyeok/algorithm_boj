# Q. 다음과 같이 0 혹은 양의 정수로만 이루어진 배열이 있을 때,
# 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 '✕' 혹은 '+' 연산자를 넣어
# 결과적으로 가장 큰 수를 구하는 프로그램을 작성하시오.
#
# 단, '+' 보다 '✕' 를 먼저 계산하는 일반적인 방식과는 달리, 모든 연산은 왼쪽에서 순서대로 이루어진다.
# ex: [0, 3, 5, 6, 1, 2, 4]
########################################################################################################################
########################################################################################################################
# 탐욕적 조건1: 무조건 *가 이득이다.
# 탐욕적 조건1에 대한 예외(1):0과 1의 경우 *를 하면 손해이다. (a*0 보다 a+0이 이득, a*1보다 a+1이 이득)
# 탐욕적 조건1에 대한 예외(2):계산값을 누적해줄 greed_sum이 0 (맨 처음의 경우, 맨 처음 target이 0일 때)이거나 1일 때(맨 처음 target이 1일 때), *연산이 되어버리면 손해이다.
########################################################################################################################

input = [0, 3, 5, 6, 1, 2, 4] # '+'와 '*'를 이용해 가장 큰 수를 만들어라
########################################################################################################################
# TODO: 탐욕적 조건을 이용해 그리디 방식으로 문제 해결
def find_max_plus_or_multiply(array):
    '''
    input으로 들어온 숫자 array에서 *와 +연산을 이용해 최대 값을 계산해 린턴해주는 메서드
    :param array: 숫자 배열이 담긴 input값
    :return: 숫자 배열의 요소들에 대해 *와 +연산을 이용해 얻을 수 있는 최대값
    '''
    greed_sum = 0
    for target in array:
        if target <= 1 or greed_sum <= 1:
            greed_sum += target
        else:
            greed_sum *= target
    return greed_sum
# 시간 복잡도: O(2*N+1) => O(N)
########################################################################################################################
result = find_max_plus_or_multiply
print("정답 = 728 현재 풀이 값 =", result([0,3,5,6,1,2,4]))
print("정답 = 8820 현재 풀이 값 =", result([3,2,1,5,9,7,4]))
print("정답 = 270 현재 풀이 값 =", result([1,1,1,3,3,2,5]))